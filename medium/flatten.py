# -*- coding: utf-8 -*-

'''
Напишите функцию flatten, которая будет принимать на вход список с
любой вложенностью и глубину распаковки. Вернуть она должна список,
где вложенные элементы соответствующего уровня распакованы, то есть
вложенное превращается в плоское.

Если 2-й аргумент не передан, все вложенные списки должны быть
распакованы.

Сигнатура: def flatten(a_list:list, depth:int=0)->list

Примечания:

- Функция не должна бросать исключений!
- Глубина распаковки всегда положительна (если указана).
- Если параметр глубины больше реальной вложенности, функция
    просто распаковывает все списки.
- Вложены могут быть только списки (не кортежи или др. контейнеры).

Примеры:

flatten([1, [2, 3]]) [1, 2, 3]
flatten([1, [2, [3]]], depth=1) [1, 2, [3]]
flatten([1, [2, [3]]], depth=2) [1, 2, 3]
flatten([1, [2, 3]], depth=100) [1, 2, 3]
'''

def recurs_flatten(arr: list, depth: int, depth_now: int) -> list:
    '''
    Рекурсивно извлекает элементы из arr до указанной глубины depth.
    depth_now - показывает текущий уровень глубины.
    '''
    # Список с результатами.
    res = list()
    # Проход по элементам списка.
    for item in arr:
        # Если элемент item это список и параметры глубины
        # (depth, depth_now) позволяют извлекать элементы.
        if isinstance(item, list) and (depth_now < depth or not depth):
            # Добавление результата в список с результатами после
            # рекурсивного вызова функции.
            res.extend(recurs_flatten(arr=item,
                                      depth=depth,
                                      depth_now=depth_now + 1))
        else:
            # Если item не список или глубина (depth, depth_now)
            # не позволяет извлекать элементы - добавляется
            # текущий элемент item таким какой он есть.
            res.append(item)
    # Возврат результата.
    return res

def flatten(a_list: list, depth: int =0) -> list:
    '''
    Возвращает список с распакованными элементами a_list указанной
    глубины depth.
    '''
    # Вызов рекурсовной функции для извлечения элементов
    # и возврат результата.
    return recurs_flatten(arr=a_list, depth=depth, depth_now=0)



tests = ((([1, [2, 3]],), [1, 2, 3]),
         (([1, [2, [3]]], 1), [1, 2, [3]]),
         (([1, [2, [3]]], 2), [1, 2, 3]),
         (([1, [2, 3]], 100), [1, 2, 3]),
         (([1, [2, [3], [4, [5]]], 6, 7], 1), [1, 2, [3], [4, [5]], 6, 7]))

for args, check in tests:
    print(flatten(*args) == check)

