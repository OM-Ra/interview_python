# -*- coding: utf-8 -*-

"""
Напишите функцию, которая будет возвращать строку,
представляющую собой ASCII-рисунок ромба. На вход
функция получает одну букву латинского алфавита в
верхнем регистре и один символ, который будет
использован в качестве фона для рисунка:

    >> diamond('A')
    A

    >> diamond('B')
     A
    B B
     A

    >> diamond('D', '-')
    ---A---
    --B-B--
    -C---C-
    D-----D
    -C---C-
    --B-B--
    ---A---

Сигнатура: def diamond(letter: str, background: str=' ') -> str:

Примечания: 

- КАЖДАЯ строка рисунка заканчивается символом '\n', 
- на вход может подаваться любая из 26 букв латинского
    алфавита и любой ASCII-символ как параметр background,
- предполагается, что ввод всегда валиден, не нужно проверок
    и исключений.
"""

def diamond(letter: str, background: str =' ') -> str:
    '''
    Рисует ромб из английского алфавита до letter символа,
    на фоне background.
    '''
    # Вспомогательные величины:
    # высота ромба;
    long_dia = ord(letter) - ord('A')
    # максимальная длина строки.
    max_len_line = 2 * long_dia + 1
    # Список со строками ромба.
    res = list()

    # Проход по высоте ромба.
    for index in range(long_dia + 1):
        # Текущий символ ромба.
        sym = chr(ord("A") + index)
        # Фон для краёв.
        sep_board = background * (long_dia - index)
        # Фон для центра.
        sep_center = background * (max_len_line - 2 * len(sep_board) - 2)
        # Форматирование строки ромба и
        #  добавление полученной строки в список с результатами.
        res.append(f'{sep_board}{sym}{sep_center}{sym * (index > 0)}{sep_board}\n')

    # Склеивание списка с результатами с перевёрнутым списком
    # не включая последний элемент, и склеивание полученного
    # списка в строку.
    return ''.join(res + res[-2::-1])



tests = ((('A'), 'A\n'),
         (('B'), ' A \nB B\n A \n'),
         (('D', '-'), '---A---\n--B-B--\n-C---C-\nD-----D\n-C---C-\n--B-B--\n---A---\n'),
         (('E', '-'), '----A----\n---B-B---\n--C---C--\n-D-----D-\nE-------E\n-D-----D-\n--C---C--\n---B-B---\n----A----\n'))

for insex, item in enumerate(tests):
    res = diamond(*item[0])
    assert res == item[1], f'test:{index:>02} >>> {item[0]} -> {res} != {item[1]}'

