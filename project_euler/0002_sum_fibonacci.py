# -*- coding: utf-8 -*-

'''
Каждый следующий элемент ряда Фибоначчи получается
при сложении двух предыдущих. Начиная с 1 и 2,
первые 10 элементов будут:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

Найдите сумму всех четных элементов ряда Фибоначчи,
которые не превышают четыре миллиона.
'''

################################################################################
#                                                                              #
#                Код по вычислению числа Фибоначчи был взят тут:               #
#                        https://habr.com/ru/post/261159                       #
#                                                                              #
################################################################################

def pow(x, n, I, mult):
    """
    Возвращает x в степени n. Предполагает, что I – это единичная матрица,
    которая перемножается с mult, а n – положительное целое
    """
    if n == 0:
        return I
    elif n == 1:
        return x
    else:
        y = pow(x, n // 2, I, mult)
        y = mult(y, y)
        if n % 2:
            y = mult(x, y)
        return y


def identity_matrix(n):
    """Возвращает единичную матрицу n на n"""
    r = list(range(n))
    return [[1 if i == j else 0 for i in r] for j in r]


def matrix_multiply(A, B):
    BT = list(zip(*B))
    return [[sum(a * b
                 for a, b in zip(row_a, col_b))
            for col_b in BT]
            for row_a in A]


def fib(n):
    F = pow([[1, 1], [1, 0]], n, identity_matrix(2), matrix_multiply)
    return F[0][1]

################################ Далее мой код #################################

def check_elem_fib(elem: int, arr: list) -> bool:
    '''
    Проверяет условие чётности элемента и чтобы
    элемент не превышал 4 миллиона.
    '''
    if not (elem & 1) and elem < 4_000_000:
        # Число добавляется в список перед возвратом
        # результата удачной проверки.
        arr.append(elem)
        return True

    return False

def sum_fibonacci(nbr: int) -> int:
    # Список где будет храниться результат вычисления числа
    # Фибоначчи, чтобы его можно было проверить, а затем,
    # использовать, не вычисляя повторно.
    tmp = list()
    # Вычисление суммы и возврат результата.
    return sum(tmp.pop()
               # Проход по индексам ряда Фибоначчи
               for item in range(nbr)
               # Вычисление числа Фибоначчи и его проверка.
               if check_elem_fib(elem=fib(item), arr=tmp)
              )


# Тесты.
tests = (
    (10, 44),
    (15, 188),
    (20, 3382),
    (25, 60696),
    (30, 257114),
    (33, 1089154),    # Далее, элементы ряда Фибоначчи будут превышать 4 миллиона.
    (34, 4613732),
    (35, 4613732),
)

for index, item in enumerate(tests):
    res = sum_fibonacci(nbr=item[0])
    assert res == item[1], f'test:{index:>02} >>> {item[0]} -> {res} != {item[1]}'

